%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Programming/Coding Assignment
% LaTeX Template
%
% This template has been downloaded from:
% http://www.latextemplates.com
%
% Original author:
% Ted Pavlic (http://www.tedpavlic.com)
%
% Note:
% The \lipsum[#] commands throughout this template generate dummy text
% to fill the template out. These commands should all be removed when 
% writing assignment content.
%
% This template uses a Perl script as an example snippet of code, most other
% languages are also usable. Configure them in the "CODE INCLUSION 
% CONFIGURATION" section.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass{article}

\usepackage{fancyhdr} % Required for custom headers
\usepackage{lastpage} % Required to determine the last page for the footer
\usepackage{extramarks} % Required for headers and footers
\usepackage[usenames,dvipsnames]{color} % Required for custom colors
\usepackage{graphicx} % Required to insert images
\usepackage{listings} % Required for insertion of code
\usepackage{courier} % Required for the courier font
\usepackage{lipsum} % Used for inserting dummy 'Lorem ipsum' text into the template
\usepackage[utf8]{inputenc} %For "spesielle" tegn som æ, ø, å og andre er det anbefalt å angi dette. Mac brukere kan vurdere applemac og ikke utf8
\usepackage{amssymb}

% Margins
\topmargin=-0.45in
\evensidemargin=0.75in
\oddsidemargin=0.75in
\textwidth=5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1} % Line spacing

% Set up the header and footer
\pagestyle{fancy}
\lhead{\hmwkAuthorName} % Top left header
\rhead{ \hmwkTitle} % Top center head
%\rhead{\firstxmark} % Top right header
\lfoot{\lastxmark} % Bottom left footer
\cfoot{} % Bottom center footer
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}} % Bottom right footer
\renewcommand\headrulewidth{0.4pt} % Size of the header rule
\renewcommand\footrulewidth{0.4pt} % Size of the footer rule

\setlength\parindent{0pt} % Removes all indentation from paragraphs

%----------------------------------------------------------------------------------------
%	CODE INCLUSION CONFIGURATION
%----------------------------------------------------------------------------------------

\definecolor{MyDarkGreen}{rgb}{0.0,0.4,0.0} % This is the color used for comments
\lstloadlanguages{Perl} % Load Perl syntax for listings, for a list of other languages supported see: ftp://ftp.tex.ac.uk/tex-archive/macros/latex/contrib/listings/listings.pdf
\lstset{language=Perl, % Use Perl in this example
        frame=single, % Single frame around code
        basicstyle=\small\ttfamily, % Use small true type font
        keywordstyle=[1]\color{Blue}\bf, % Perl functions bold and blue
        keywordstyle=[2]\color{Purple}, % Perl function arguments purple
        keywordstyle=[3]\color{Blue}\underbar, % Custom functions underlined and blue
        identifierstyle=, % Nothing special about identifiers                                         
        commentstyle=\usefont{T1}{pcr}{m}{sl}\color{MyDarkGreen}\small, % Comments small dark green courier font
        stringstyle=\color{Purple}, % Strings are purple
        showstringspaces=false, % Don't put marks in string spaces
        tabsize=5, % 5 spaces per tab
        %
        % Put standard Perl functions not included in the default language here
        morekeywords={rand},
        %
        % Put Perl function parameters here
        morekeywords=[2]{on, off, interp},
        %
        % Put user defined functions here
        morekeywords=[3]{test},
       	%
        morecomment=[l][\color{Blue}]{...}, % Line continuation (...) like blue comment
        numbers=left, % Line numbers on left
        firstnumber=1, % Line numbers start with line 1
        numberstyle=\tiny\color{Blue}, % Line numbers are blue and small
        stepnumber=5 % Line numbers go in steps of 5
}

% Creates a new command to include a perl script, the first parameter is the filename of the script (without .pl), the second parameter is the caption
\newcommand{\perlscript}[2]{
\begin{itemize}
\item[]\lstinputlisting[caption=#2,label=#1]{#1.pl}
\end{itemize}
}

%----------------------------------------------------------------------------------------
%	DOCUMENT STRUCTURE COMMANDS
%	Skip this unless you know what you're doing
%----------------------------------------------------------------------------------------

% Header and footer for when a page split occurs within a problem environment
\newcommand{\enterProblemHeader}[1]{
\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
}

% Header and footer for when a page split occurs between problem environments
\newcommand{\exitProblemHeader}[1]{
\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak
\nobreak\extramarks{#1}{}\nobreak
}

\setcounter{secnumdepth}{0} % Removes default section numbers
\newcounter{homeworkProblemCounter} % Creates a counter to keep track of the number of problems

\newcommand{\homeworkProblemName}{}
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]{ % Makes a new environment called homeworkProblem which takes 1 argument (custom name) but the default is "Problem #"
\stepcounter{homeworkProblemCounter} % Increase counter for number of problems
\renewcommand{\homeworkProblemName}{#1} % Assign \homeworkProblemName the name of the problem
\section{\homeworkProblemName} % Make a section in the document with the custom problem count
\enterProblemHeader{\homeworkProblemName} % Header and footer within the environment
}{
\exitProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

\newcommand{\problemAnswer}[1]{ % Defines the problem answer command with the content as the only argument
\noindent\framebox[\columnwidth][c]{\begin{minipage}{0.98\columnwidth}#1\end{minipage}} % Makes the box around the problem answer and puts the content inside
}

\newcommand{\homeworkSectionName}{}
\newenvironment{homeworkSection}[1]{ % New environment for sections within homework problems, takes 1 argument - the name of the section
\renewcommand{\homeworkSectionName}{#1} % Assign \homeworkSectionName to the name of the section from the environment argument
\subsection{\homeworkSectionName} % Make a subsection with the custom name of the subsection
\enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]} % Header and footer within the environment
}{
\enterProblemHeader{\homeworkProblemName} % Header and footer after the environment
}

%----------------------------------------------------------------------------------------
%	NAME AND CLASS SECTION
%----------------------------------------------------------------------------------------

\newcommand{\hmwkTitle}{Problem set\ \#4} % Assignment title
\newcommand{\hmwkDueDate}{Monday,\ February\ 25,\ 2013} % Due date
\newcommand{\hmwkClass}{TMA4280\ } % Course/class
\newcommand{\hmwkClassTime}{} % Class/lecture time
\newcommand{\hmwkClassInstructor}{} % Teacher/lecturer
\newcommand{\hmwkAuthorName}{Simen Haugerud Granlund \&\ Steffen Pøhner Henriksen} % Your name

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title{
\vspace{2in}
\textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
\normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate}\\
\vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
\vspace{3in}
}

\author{\textbf{\hmwkAuthorName}}
\date{} % Insert date here if you want it to appear below your name

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle

%----------------------------------------------------------------------------------------
%	TABLE OF CONTENTS
%----------------------------------------------------------------------------------------

%\setcounter{tocdepth}{1} % Uncomment this line if you don't want subsections listed in the ToC

% \newpage
% \tableofcontents
 \newpage

%----------------------------------------------------------------------------------------
%	SOLUTION
%----------------------------------------------------------------------------------------

% To have just one problem per page, simply put a \clearpage after each problem

\section{}
	
	In this assignment we will write a program in C to compute a sum of vectors. More precisely we will consider a vector $ v \in \mathbb{R}^n $ defined like this:

	$$ v(i) = \frac{1}{i^2}, \ i=1,...,n$$

	The sum of these vectors will converge to $ \frac{\pi^2}{6} $ and is mathematically expressed:

	$$ S_n = \sum\limits_{i=1}^n v(i) $$ 

	First we will compute the sum using an serial approach on one processor. Later we will improve the program using multithreading techniques. Common for all the versions of our program is the common.h/common.c files. These files are produced by Arne Morten Kvarving (our lecturer). They create vectors, and matrices continously in memory, and defines structs that contains information about the data and the data itself. This problem set focuses on improving code by use of multithreading and theory, and we don't consider allocating data in memory an important goal here. Therefore we will use these files not written by us to help focus on the main tasks.

	The standard serial version and our starting point throughout this problem set is as follows:
	\lstinputlisting[language=C, caption=Serial version]{../src/oving4-serial.c}
    \
    We created a serial program using BLAS in an attempt to make the serial code optimal. We took advantage of the properties of the inner product to do so. Using a vector consisting of pointers to a double of value one, we were able to use BLAS for the summation. It turned out that this was slower due to allocation of memory for the vector of pointers. Allocating and creating the vectors are dominant to the computations needed and kills the potential speedup.
    \\ \\ 
    The parallell verison of the program should be suitable for shared memory computers. This favors the use of OpenMP as this library takes advantage of the shared memory. The difference from the serial version is the doSum method. We have added a pragma to the for loop, and peform an reduction on the sum variable. The schedule mode was set to static due to the similar workload of every loop. 
    \lstinputlisting[language=C, firstline=22, lastline=31, caption=OpenMP version]{../src/oving4-openmp.c}
    \
    There is also expected of us to create a program suitable for distrubuted memory systems. This smells of MPI. Our MPI-program splits the vector according to the number of processes. Each process then calculate it's part of the sum. An \textit{MPI\_Reduce} call then gathers all the parts, and sums them to the final sum. The final sum ends up on the root process which we chose to be the one with rank 0.
    \lstinputlisting[language=C, firstline=53, lastline=70, caption=MPI version]{../src/oving4-openmpi.c}
    \
    Comparing the results of $ S-S_N $ in our MPI program on 4 processes, 16 processes and the serial version resulted in exactly the same results. However, this it not always the case when using the MPI\_Reduce with the parameter MPI\_SUM. This is becasue this method takes advantage of the associativity nature of sums, and since it can happen that it sums the parts in different order we can get different round-off errors and therefore different results.

    Considering the memory requirement our program is pretty smart. All processes need some basic data like number of processes, rank, the correct sum, the part sum and the split vectors. Each process only generates $ N/P $ vector elements, therefore the memory consumption per process decreases with more processes. But of course the total memory consumption increases due to the mentioned overhead variables.

    When generating a vector element we use the formula $ v(i) = \frac{1}{i^2}$. Which requires three floating point operations. Generating the vector v takes three floating point operations per number of elements ($n$). To compute the total sum $S_n$ using the OpenMP version (for shared memory computers) we use the same method to generate the vectors, each thread sums $\frac{n}{T}$ elements with one floating operation per sum plus the reduction in the end which takes $T-1$ floating point operations, where $T$ is number of threads.

    $$ F(n) = 3n + \frac{n}{T}T+(T-1) = 4n + T - 1 $$

    Our multi-processor program is well balanced because each process is responsible for creating its own vector elements, and doing calculation on them. And each process takes exactly the same amount of elements, which takes the same amount of time. One process is responsible for collecting the data in the end and therefore the load on this is slightly larger, but negligble.@

    We compared the time it took to compute the difference $ S - S_n $ on the serial version and the OpenMP version. The OpenMP version was slightly faster when $n>8192$, but the total time was $0.000401s$  for the serial version. This is such a small trivial problem that the effort going into parallelize it is not worth it. It takes well under one hundred of a second doing the computations to the precision of the double precision datatype on the serial version. The overhead of splitting up the problem is dominating the computation time of the OpenMP version. In addition we do know the exact value. This makes it only of academic interest to compute an apporoximation.

    The source of our code is delivered as seperate files with this report.


%----------------------------------------------------------------------------------------

\end{document}